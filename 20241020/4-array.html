<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        let userName = 'Loki'; //value of str，一個值
        let userAge = 12; //val of num，一個值

        let myAryAA = new Array(); //正式宣告，透過內建建構式(產生一個大型物件，裡面包含一些可用的原生鍊prototype)來完成，一般人偷懶不會用這下
        let myAryAB = []; //空陣列的語法糖果，暴力指定給變數
        let myAryAC = new Array(1, 2, 'A', true);


        let myAryB = ['A', true, 3]; //value of array，可以指定n個值，每個值有自己的index(索引)

        //let myAryB = ['B', true, 3];
        //let myAryB =[0];
        //查陣列長度可加.length
        //myAryB.pop == myAryB['pop']

        //根據 push,pop,shift, unshift 來操作陣列增減長度與內容
        //自行操作不再示範，ex:myAryB.push('B,true,3')
        //工作上不太喜歡這樣用

        /////////////////////////////////////

        let aryInit = [1, 2, 3]; //預設值
        let errCloneAry = aryInit; //預設ary因為指定，他們的記憶體位置都一樣，這叫記憶體汙染

        let realCloneAry = [...aryInit]; //解構與重構，將陣列拆開，重新組合新陣列，在指定給b

        let a = [1, 2, 3]; //被複製的固定陣列
        let b = [...a]; //重構出一乾淨的陣列，指定給b
        b.push('Loki');
        console.log(b); //B與a是不同的陣列，他們的記憶體位置不同

        let c = [...a, 'Loki', ...b]; //==b.push('Loki');

        console.clear();

        //a.push('C');
        a = ['Loki', ...a, 'C'];


        ////////////////////////////

        function hello() {
            console.log('hello');
        }

        let minAry = ['A', 'B', 'C'];

        //bigAry = [hello, minAry]; //巢狀array，二(N)維陣列
        let bigAry = [
            ['A', 'B', 'C'],
            [10, ['xx', 'yy'], 30]
        ]; // 巢狀array，二(N)維陣列

        ////////////////////////////////////
        //let ary1 = [1,2,3];
        //ary1 = [...ary1,4,5,6];
        const ary2 = [1,2,3]; //保護變數有無重新指定(記憶體改變)
        ary2.push('A');








    </script>
</body>

</html>